Index: app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.ui.activities;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.Menu;\r\nimport android.view.MenuItem;\r\nimport android.widget.Button;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AlertDialog;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.appcompat.widget.Toolbar;\r\nimport androidx.lifecycle.ViewModelProvider;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.bumptech.glide.Glide;\r\nimport com.example.cooking.Recipe.Ingredient;\r\nimport com.example.cooking.Recipe.Step;\r\nimport com.example.cooking.R;\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.ui.adapters.StepAdapter;\r\nimport com.example.cooking.ui.adapters.IngredientViewAdapter;\r\nimport com.example.cooking.ui.viewmodels.RecipeDetailViewModel;\r\nimport com.google.android.material.floatingactionbutton.FloatingActionButton;\r\nimport com.google.android.material.imageview.ShapeableImageView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\n/**\r\n * Активность для отображения подробной информации о рецепте.\r\n * Показывает полное описание, ингредиенты и инструкцию.\r\n */\r\npublic class RecipeDetailActivity extends AppCompatActivity {\r\n    // Константы для передачи данных между активностями\r\n    public static final String EXTRA_RECIPE_TITLE = \"recipe_title\";\r\n    public static final String EXTRA_RECIPE_CREATOR = \"recipe_creator\";\r\n    public static final String EXTRA_RECIPE_INSTRUCTOR = \"recipe_instructor\";\r\n    public static final String EXTRA_RECIPE_FOOD = \"recipe_food\";\r\n    public static final String EXTRA_RECIPE_PHOTO_URL = \"photo_url\";\r\n    public static final String EXTRA_SELECTED_RECIPE = \"SELECTED_RECIPE\"; // <-- Ключ для Parcelable\r\n    private static final String TAG = \"RecipeDetailActivity\";\r\n    private static final int EDIT_RECIPE_REQUEST = 1001;\r\n    \r\n    // UI-компоненты\r\n    private FloatingActionButton fabLike;\r\n    private TextView titleTextView;\r\n    private ShapeableImageView recipeImageView;\r\n    private TextView createdAtTextView;\r\n    private Button decreasePortionButton;\r\n    private Button increasePortionButton;\r\n    private TextView portionCountTextView;\r\n    private Button toListButton;\r\n    private Button toCartButton;\r\n    private RecyclerView stepsRecyclerView;\r\n    private StepAdapter stepAdapter;\r\n    private RecyclerView ingredientsRecyclerView;\r\n    private IngredientViewAdapter ingredientAdapter;\r\n    \r\n    // Данные рецепта\r\n    private Recipe currentRecipe; // Будем хранить весь объект\r\n    private int recipeId;\r\n    private String userId;\r\n    private int currentPortionCount = 1;\r\n    private List<Step> steps = new ArrayList<>();\r\n    private List<Ingredient> ingredients = new ArrayList<>();\r\n    \r\n    // ViewModel\r\n    private RecipeDetailViewModel viewModel;\r\n    \r\n    /**\r\n     * Инициализирует активность и заполняет её данными о рецепте\r\n     */\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_recipe_detail);\r\n\r\n        // Настраиваем toolbar\r\n        Toolbar toolbar = findViewById(R.id.toolbar);\r\n        setSupportActionBar(toolbar);\r\n        \r\n        // Настраиваем обработчик нажатия на кнопку \"назад\"\r\n        toolbar.setNavigationOnClickListener(v -> finish());\r\n\r\n        // Получаем данные о рецепте из Intent\r\n        currentRecipe = getIntent().getParcelableExtra(EXTRA_SELECTED_RECIPE); // Используем константу\r\n\r\n        // Проверяем, что данные получены\r\n        if (currentRecipe == null) {\r\n            Log.e(TAG, \"Объект Recipe не найден в Intent extras. Ключ: \" + EXTRA_SELECTED_RECIPE);\r\n            Toast.makeText(this, \"Ошибка: Не удалось загрузить данные рецепта.\", Toast.LENGTH_LONG).show();\r\n            finish(); // Закрываем активность, если данных нет\r\n            return;\r\n        }\r\n\r\n        // Извлекаем данные из объекта Recipe\r\n        recipeId = currentRecipe.getId();\r\n        userId = currentRecipe.getUserId();\r\n        // Списки берем напрямую из объекта\r\n        this.ingredients = currentRecipe.getIngredients() != null ? new ArrayList<>(currentRecipe.getIngredients()) : new ArrayList<>();\r\n        this.steps = currentRecipe.getSteps() != null ? new ArrayList<>(currentRecipe.getSteps()) : new ArrayList<>();\r\n\r\n        // Логируем полученные данные для отладки\r\n        Log.d(TAG, \"Получен рецепт: ID = \" + recipeId + \", Название = \" + currentRecipe.getTitle());\r\n        Log.d(TAG, \"Кол-во ингредиентов: \" + this.ingredients.size());\r\n        Log.d(TAG, \"Кол-во шагов: \" + this.steps.size());\r\n        Log.d(TAG, \"Дата создания: \" + currentRecipe.getCreated_at());\r\n        Log.d(TAG, \"ID пользователя: \" + userId);\r\n        Log.d(TAG, \"URL фото: \" + currentRecipe.getPhoto_url());\r\n        Log.d(TAG, \"Лайкнут: \" + currentRecipe.isLiked());\r\n        \r\n        // Инициализируем UI-компоненты\r\n        titleTextView = findViewById(R.id.recipe_title);\r\n        recipeImageView = findViewById(R.id.recipe_image);\r\n        createdAtTextView = findViewById(R.id.recipe_date);\r\n        fabLike = findViewById(R.id.like_button);\r\n        decreasePortionButton = findViewById(R.id.decrease_portion);\r\n        increasePortionButton = findViewById(R.id.increase_portion);\r\n        portionCountTextView = findViewById(R.id.portion_count);\r\n        stepsRecyclerView = findViewById(R.id.steps_recyclerview);\r\n        ingredientsRecyclerView = findViewById(R.id.ingredients_recyclerview);\r\n        \r\n        // Настраиваем RecyclerView для шагов\r\n        setupStepsRecyclerView();\r\n        \r\n        // Настраиваем RecyclerView для ингредиентов\r\n        setupIngredientsRecyclerView();\r\n\r\n        // Инициализируем и настраиваем ViewModel\r\n        viewModel = new ViewModelProvider(this).get(RecipeDetailViewModel.class);\r\n        // Вместо передачи всех полей, передаем только ID\r\n        // ViewModel должен сам загрузить Recipe из репозитория по ID\r\n        viewModel.loadRecipe(recipeId); \r\n        \r\n        // Настраиваем наблюдателей LiveData\r\n        setupObservers();\r\n        \r\n        // Настраиваем обработчики событий\r\n        setupEventListeners();\r\n\r\n        // Первичное отображение данных из Intent (пока ViewModel загружает)\r\n        Log.d(TAG, \"onCreate: Установка начального UI...\");\r\n        if (titleTextView != null && currentRecipe != null) {\r\n            Log.d(TAG, \"onCreate: Установка заголовка: \" + currentRecipe.getTitle());\r\n            titleTextView.setText(currentRecipe.getTitle());\r\n        } else {\r\n            Log.e(TAG, \"onCreate: titleTextView is null или currentRecipe is null перед установкой заголовка\");\r\n        }\r\n        createdAtTextView.setText(String.format(Locale.getDefault(), \"Создано: %s\", currentRecipe.getCreated_at()));\r\n        updateLikeButton(currentRecipe.isLiked());\r\n        if (recipeImageView != null && currentRecipe != null && currentRecipe.getPhoto_url() != null && !currentRecipe.getPhoto_url().isEmpty()) {\r\n            Log.d(TAG, \"onCreate: Загрузка изображения Glide: \" + currentRecipe.getPhoto_url());\r\n            Glide.with(this)\r\n                 .load(currentRecipe.getPhoto_url())\r\n                 .placeholder(R.drawable.placeholder_image)\r\n                 .error(R.drawable.error_image)\r\n                 .into(recipeImageView);\r\n        } else {\r\n            Log.w(TAG, \"onCreate: Не удалось загрузить изображение Glide (ImageView null, Recipe null, URL null/пустой)\");\r\n             if(recipeImageView != null) recipeImageView.setImageResource(R.drawable.default_recipe_image); // Установим дефолтное изображение\r\n        }\r\n        updatePortionCount();\r\n    }\r\n    \r\n    /**\r\n     * Настраивает RecyclerView для шагов рецепта\r\n     */\r\n    private void setupStepsRecyclerView() {\r\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this);\r\n        stepsRecyclerView.setLayoutManager(layoutManager);\r\n        // Создаем адаптер\r\n        stepAdapter = new StepAdapter(this); \r\n        stepsRecyclerView.setAdapter(stepAdapter);\r\n        // Сразу передаем шаги, полученные из Intent\r\n        stepAdapter.submitList(this.steps); \r\n        Log.d(TAG, \"setupStepsRecyclerView: Передано шагов в адаптер: \" + this.steps.size()); // Добавим лог\r\n    }\r\n    \r\n    /**\r\n     * Настраивает RecyclerView для ингредиентов\r\n     */\r\n    private void setupIngredientsRecyclerView() {\r\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this);\r\n        ingredientsRecyclerView.setLayoutManager(layoutManager);\r\n        // Инициализируем адаптер списком, полученным из Parcelable\r\n        ingredientAdapter = new IngredientViewAdapter(this, this.ingredients);\r\n        ingredientsRecyclerView.setAdapter(ingredientAdapter);\r\n    }\r\n    \r\n    /**\r\n     * Настраивает обработчики событий\r\n     */\r\n    private void setupEventListeners() {\r\n        // Настраиваем клик по кнопке \"лайк\"\r\n        fabLike.setOnClickListener(v -> viewModel.toggleLike());\r\n        \r\n        // Настраиваем кнопки изменения порции\r\n        decreasePortionButton.setOnClickListener(v -> {\r\n            if (currentPortionCount > 1) {\r\n                currentPortionCount--;\r\n                updatePortionCount();\r\n            }\r\n        });\r\n        \r\n        increasePortionButton.setOnClickListener(v -> {\r\n            currentPortionCount++;\r\n            updatePortionCount();\r\n        });\r\n            }\r\n    \r\n    /**\r\n     * Обновляет отображение количества порций\r\n     */\r\n    private void updatePortionCount() {\r\n        portionCountTextView.setText(String.valueOf(currentPortionCount));\r\n        // Убедимся, что адаптер не null перед вызовом\r\n        if (ingredientAdapter != null) { \r\n            ingredientAdapter.updatePortionCount(currentPortionCount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Настраивает наблюдение за данными из ViewModel\r\n     */\r\n    private void setupObservers() {\r\n        // Наблюдаем за данными рецепта из ViewModel\r\n        viewModel.getRecipe().observe(this, recipeFromVm -> {\r\n            if (recipeFromVm != null) {\r\n                Log.d(TAG, \"Получен обновленный рецепт из ViewModel. Шагов: \" + (recipeFromVm.getSteps() != null ? recipeFromVm.getSteps().size() : \"null\"));\r\n                currentRecipe = recipeFromVm; // Обновляем текущий рецепт\r\n                updateUI(currentRecipe); // Обновляем весь UI свежими данными\r\n            } else {\r\n                Log.w(TAG, \"ViewModel вернул null Recipe объект.\");\r\n                // Можно показать сообщение об ошибке или использовать данные из Intent\r\n                // если они были успешно получены ранее\r\n                if (currentRecipe != null) { \r\n                    updateUI(currentRecipe); // Показываем то, что пришло в Intent\r\n                } else {\r\n                     Toast.makeText(this, \"Не удалось загрузить детали рецепта.\", Toast.LENGTH_SHORT).show();\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за состоянием лайка\r\n        viewModel.isLiked().observe(this, this::updateLikeButton);\r\n        \r\n        // Наблюдаем за сообщениями об ошибках\r\n        viewModel.getErrorMessage().observe(this, error -> {\r\n            if (error != null && !error.isEmpty()) {\r\n                Toast.makeText(this, error, Toast.LENGTH_LONG).show();\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за статусом удаления\r\n        viewModel.isDeleteSuccess().observe(this, isSuccess -> {\r\n            if (isSuccess) {\r\n                Toast.makeText(this, \"Рецепт успешно удален\", Toast.LENGTH_SHORT).show();\r\n                setResult(RESULT_OK);\r\n                finish();\r\n            }\r\n        });\r\n        \r\n        // Наблюдаем за разрешением на редактирование\r\n        viewModel.hasEditPermission().observe(this, hasPermission -> {\r\n            invalidateOptionsMenu(); // Обновляем меню\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Обновляет UI элементы данными из рецепта (полученного из ViewModel)\r\n     */\r\n    private void updateUI(Recipe recipe) {\r\n        if (recipe == null) {\r\n            Log.w(TAG, \"updateUI вызван с null Recipe объектом.\");\r\n            return;\r\n        }\r\n        Log.d(TAG, \"updateUI: Обновление UI для рецепта: \" + recipe.getTitle());\r\n        \r\n        if (titleTextView != null) {\r\n             Log.d(TAG, \"updateUI: Установка заголовка: \" + recipe.getTitle());\r\n            titleTextView.setText(recipe.getTitle());\r\n        } else {\r\n             Log.e(TAG, \"updateUI: titleTextView is null\");\r\n        }\r\n        createdAtTextView.setText(String.format(Locale.getDefault(), \"Создано: %s\", recipe.getCreated_at()));\r\n        updateLikeButton(recipe.isLiked());\r\n\r\n        // Обновляем адаптеры новыми данными\r\n        this.ingredients = recipe.getIngredients() != null ? new ArrayList<>(recipe.getIngredients()) : new ArrayList<>();\r\n        if (ingredientAdapter != null) {\r\n            ingredientAdapter.updateIngredients(this.ingredients);\r\n            ingredientAdapter.updatePortionCount(currentPortionCount); \r\n        } else {\r\n             Log.e(TAG, \"updateUI: ingredientAdapter is null\");\r\n        }\r\n        \r\n        this.steps = recipe.getSteps() != null ? new ArrayList<>(recipe.getSteps()) : new ArrayList<>();\r\n        if (stepAdapter != null) {\r\n             stepAdapter.submitList(this.steps);\r\n        } else {\r\n             Log.e(TAG, \"updateUI: stepAdapter is null\");\r\n        }\r\n\r\n        if (recipeImageView != null && recipe.getPhoto_url() != null && !recipe.getPhoto_url().isEmpty()) {\r\n             Log.d(TAG, \"updateUI: Загрузка изображения Glide: \" + recipe.getPhoto_url());\r\n             Glide.with(this)\r\n                  .load(recipe.getPhoto_url())\r\n                  .placeholder(R.drawable.placeholder_image)\r\n                  .error(R.drawable.error_image)\r\n                  .into(recipeImageView);\r\n        } else {\r\n             Log.w(TAG, \"updateUI: Не удалось загрузить изображение Glide (ImageView null, URL null/пустой)\");\r\n             if(recipeImageView != null) recipeImageView.setImageResource(R.drawable.default_recipe_image); // Установим дефолтное изображение\r\n        }\r\n        invalidateOptionsMenu(); \r\n    }\r\n    \r\n    /**\r\n     * Обновляет состояние кнопки лайка\r\n     */\r\n    private void updateLikeButton(boolean isLiked) {\r\n        if (isLiked) {\r\n            fabLike.setImageResource(R.drawable.ic_favorite); // Закрашенный лайк\r\n        } else {\r\n            fabLike.setImageResource(R.drawable.ic_favorite_border); // Пустой лайк\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public boolean onCreateOptionsMenu(Menu menu) {\r\n        getMenuInflater().inflate(R.menu.menu_recipe_detail, menu);\r\n        MenuItem editItem = menu.findItem(R.id.action_edit);\r\n        MenuItem deleteItem = menu.findItem(R.id.action_delete);\r\n\r\n        // Показываем или скрываем кнопки в зависимости от разрешений\r\n        Boolean hasPermission = viewModel.hasEditPermission().getValue();\r\n        if (editItem != null) editItem.setVisible(hasPermission != null && hasPermission);\r\n        if (deleteItem != null) deleteItem.setVisible(hasPermission != null && hasPermission);\r\n\r\n        return true;\r\n    }\r\n    \r\n    @Override\r\n    public boolean onOptionsItemSelected(MenuItem item) {\r\n        Recipe recipe = viewModel.getRecipe().getValue();\r\n        if (recipe == null) {\r\n            return super.onOptionsItemSelected(item);\r\n        }\r\n        \r\n        int itemId = item.getItemId();\r\n        \r\n        if (itemId == R.id.action_share) {\r\n            shareRecipe(recipe);\r\n            return true;\r\n        } else if (itemId == R.id.action_edit) {\r\n            editRecipe(recipe);\r\n            return true;\r\n        } else if (itemId == R.id.action_delete) {\r\n            showDeleteConfirmationDialog();\r\n            return true;\r\n        }\r\n        \r\n        return super.onOptionsItemSelected(item);\r\n    }\r\n    \r\n    /**\r\n     * Показывает диалог подтверждения удаления рецепта\r\n     */\r\n    private void showDeleteConfirmationDialog() {\r\n        new AlertDialog.Builder(this)\r\n                .setTitle(\"Удалить рецепт?\")\r\n                .setMessage(\"Вы уверены, что хотите удалить этот рецепт? Это действие необратимо.\")\r\n                .setPositiveButton(\"Удалить\", (dialog, which) -> {\r\n                    Recipe recipe = viewModel.getRecipe().getValue();\r\n                    if (recipe != null) {\r\n                        viewModel.deleteRecipe(recipe.getId());\r\n                    } else {\r\n                        Toast.makeText(this, \"Ошибка: Не удалось получить ID рецепта для удаления.\", Toast.LENGTH_SHORT).show();\r\n                    }\r\n                })\r\n                .setNegativeButton(\"Отмена\", null)\r\n                .show();\r\n    }\r\n    \r\n    /**\r\n     * Делится рецептом через другие приложения\r\n     */\r\n    private void shareRecipe(Recipe recipe) {\r\n        if (recipe == null) return;\r\n\r\n        Intent shareIntent = new Intent(Intent.ACTION_SEND);\r\n        shareIntent.setType(\"text/plain\");\r\n        String shareBody = \"Посмотри рецепт: \" + recipe.getTitle() + \"\\nПодробнее: [ссылка на приложение или веб-версию]\"; // TODO: Добавить ссылку\r\n        shareIntent.putExtra(Intent.EXTRA_SUBJECT, \"Рецепт: \" + recipe.getTitle());\r\n        shareIntent.putExtra(Intent.EXTRA_TEXT, shareBody);\r\n\r\n        startActivity(Intent.createChooser(shareIntent, \"Поделиться рецептом через\"));\r\n    }\r\n    \r\n    /**\r\n     * Открывает активность редактирования рецепта\r\n     */\r\n    private void editRecipe(Recipe recipe) {\r\n        if (recipe == null) return;\r\n        Intent intent = new Intent(this, EditRecipeActivity.class);\r\n        intent.putExtra(EditRecipeActivity.EXTRA_EDIT_RECIPE, recipe);\r\n        startActivityForResult(intent, EDIT_RECIPE_REQUEST);\r\n    }\r\n    \r\n    @Override\r\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n        super.onActivityResult(requestCode, resultCode, data);\r\n        \r\n        if (requestCode == EDIT_RECIPE_REQUEST && resultCode == RESULT_OK) {\r\n            // Рецепт был изменен, нужно перезагрузить данные\r\n            Toast.makeText(this, \"Рецепт обновлен\", Toast.LENGTH_SHORT).show();\r\n            if (viewModel != null) {\r\n                viewModel.loadRecipe(recipeId); // Заставляем ViewModel перезагрузить данные\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java b/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java
--- a/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java	(revision 36bc0188d2d0ff0b726e46a412f1dc95ae03a425)
+++ b/app/src/main/java/com/example/cooking/ui/activities/RecipeDetailActivity.java	(date 1745090490809)
@@ -262,6 +262,8 @@
                 Toast.makeText(this, "Рецепт успешно удален", Toast.LENGTH_SHORT).show();
                 setResult(RESULT_OK);
                 finish();
+
+
             }
         });
         
Index: app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cooking.ui.viewmodels;\r\n\r\nimport android.app.Application;\r\nimport android.util.Log;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.lifecycle.AndroidViewModel;\r\nimport androidx.lifecycle.LiveData;\r\nimport androidx.lifecycle.MutableLiveData;\r\n\r\nimport com.example.cooking.Recipe.Recipe;\r\nimport com.example.cooking.data.database.RecipeEntity;\r\nimport com.example.cooking.data.repositories.RecipeRepository;\r\nimport com.example.cooking.network.services.RecipeDeleter;\r\nimport com.example.cooking.utils.MySharedPreferences;\r\nimport com.example.cooking.data.repositories.RecipeLocalRepository;\r\n\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport okhttp3.Call;\r\nimport okhttp3.Callback;\r\nimport okhttp3.MediaType;\r\nimport okhttp3.OkHttpClient;\r\nimport okhttp3.Request;\r\nimport okhttp3.RequestBody;\r\nimport okhttp3.Response;\r\n\r\n/**\r\n * ViewModel для RecipeDetailActivity\r\n * Управляет данными и логикой экрана детального просмотра рецепта\r\n */\r\npublic class RecipeDetailViewModel extends AndroidViewModel {\r\n\r\n    private static final String TAG = \"RecipeDetailViewModel\";\r\n    private static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\r\n\r\n    private final OkHttpClient client;\r\n    private final ExecutorService executor;\r\n    private final RecipeDeleter recipeDeleter;\r\n    private final RecipeLocalRepository localRepository;\r\n    private final RecipeRepository recipeRepository;\r\n    private final MySharedPreferences preferences;\r\n\r\n    // LiveData для хранения состояний\r\n    private final MutableLiveData<Recipe> recipe = new MutableLiveData<>();\r\n    private final MutableLiveData<Boolean> isLiked = new MutableLiveData<>(false);\r\n    private final MutableLiveData<Boolean> isDeleting = new MutableLiveData<>(false);\r\n    private final MutableLiveData<Boolean> deleteSuccess = new MutableLiveData<>(false);\r\n    private final MutableLiveData<String> errorMessage = new MutableLiveData<>();\r\n    private final MutableLiveData<Boolean> hasEditPermission = new MutableLiveData<>(false);\r\n\r\n    public RecipeDetailViewModel(@NonNull Application application) {\r\n        super(application);\r\n        client = new OkHttpClient();\r\n        executor = Executors.newSingleThreadExecutor();\r\n        recipeDeleter = new RecipeDeleter(application);\r\n        localRepository = new RecipeLocalRepository(application);\r\n        recipeRepository = new RecipeRepository(application);\r\n        preferences = new MySharedPreferences(application);\r\n    }\r\n\r\n    /**\r\n     * Загружает данные рецепта по ID из кэша репозитория.\r\n     * @param recipeId ID рецепта для загрузки.\r\n     */\r\n    public void loadRecipe(int recipeId) {\r\n        if (recipeId == -1) {\r\n            errorMessage.postValue(\"Неверный ID рецепта.\");\r\n            return;\r\n        }\r\n        Log.d(TAG, \"Загрузка рецепта с ID: \" + recipeId + \" из кэша репозитория\");\r\n        executeIfActive(() -> {\r\n            // Загружаем весь список из кэша\r\n            RecipeRepository.Result<List<Recipe>> cachedResult = recipeRepository.loadFromCache();\r\n            \r\n            if (cachedResult.isSuccess()) {\r\n                List<Recipe> cachedRecipes = ((RecipeRepository.Result.Success<List<Recipe>>) cachedResult).getData();\r\n                Recipe foundRecipe = null;\r\n                // Ищем нужный рецепт в списке\r\n                for (Recipe r : cachedRecipes) {\r\n                    if (r.getId() == recipeId) {\r\n                        foundRecipe = r;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (foundRecipe != null) {\r\n                    recipe.postValue(foundRecipe);\r\n                    isLiked.postValue(foundRecipe.isLiked()); // Устанавливаем статус лайка\r\n                    checkEditPermission(foundRecipe.getUserId()); // Проверяем права\r\n                    Log.d(TAG, \"Рецепт ID \" + recipeId + \" найден в кэше: \" + foundRecipe.getTitle());\r\n                } else {\r\n                    errorMessage.postValue(\"Рецепт с ID \" + recipeId + \" не найден в кэше.\");\r\n                    Log.e(TAG, \"Рецепт с ID \" + recipeId + \" не найден в загруженном кэше.\");\r\n                }\r\n            } else {\r\n                // Ошибка загрузки из кэша\r\n                String error = ((RecipeRepository.Result.Error<List<Recipe>>) cachedResult).getErrorMessage();\r\n                errorMessage.postValue(\"Ошибка загрузки из кэша: \" + error);\r\n                Log.e(TAG, \"Ошибка загрузки рецептов из кэша: \" + error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Проверяет, имеет ли пользователь права на редактирование рецепта\r\n     */\r\n    private void checkEditPermission(String recipeUserId) {\r\n        String currentUserId = preferences.getString(\"userId\", \"0\");\r\n        int permission = preferences.getInt(\"permission\", 1);\r\n        \r\n        // Пользователь может редактировать, если он автор или администратор\r\n        boolean canEdit = (recipeUserId != null && recipeUserId.equals(currentUserId)) || permission == 2;\r\n        hasEditPermission.postValue(canEdit);\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с информацией о рецепте\r\n     */\r\n    public LiveData<Recipe> getRecipe() {\r\n        return recipe;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с состоянием лайка\r\n     */\r\n    public LiveData<Boolean> isLiked() {\r\n        return isLiked;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с состоянием процесса удаления\r\n     */\r\n    public LiveData<Boolean> isDeleting() {\r\n        return isDeleting;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с результатом удаления\r\n     */\r\n    public LiveData<Boolean> isDeleteSuccess() {\r\n        return deleteSuccess;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с текстом ошибки\r\n     */\r\n    public LiveData<String> getErrorMessage() {\r\n        return errorMessage;\r\n    }\r\n\r\n    /**\r\n     * Возвращает LiveData с информацией о наличии прав на редактирование\r\n     */\r\n    public LiveData<Boolean> hasEditPermission() {\r\n        return hasEditPermission;\r\n    }\r\n    \r\n    /**\r\n     * Изменяет состояние \"лайка\" для рецепта\r\n     */\r\n    public void toggleLike() {\r\n        Recipe currentRecipe = recipe.getValue();\r\n        if (currentRecipe == null) {\r\n            errorMessage.postValue(\"Данные рецепта еще не загружены.\");\r\n            return;\r\n        }\r\n        \r\n        String userId = preferences.getString(\"userId\", \"0\");\r\n        if (userId.equals(\"0\")) {\r\n            errorMessage.postValue(\"Для добавления в избранное необходимо войти в аккаунт\");\r\n            return;\r\n        }\r\n        \r\n        boolean currentLikeState = isLiked.getValue() != null ? isLiked.getValue() : false;\r\n        boolean newLikeState = !currentLikeState;\r\n        isLiked.postValue(newLikeState);\r\n        currentRecipe.setLiked(newLikeState);\r\n        \r\n        sendLikeRequest(userId, currentRecipe.getId(), newLikeState);\r\n        \r\n        executeIfActive(() -> {\r\n            localRepository.updateLikeStatus(currentRecipe.getId(), newLikeState);\r\n            Log.d(TAG, \"Статус лайка для ID \" + currentRecipe.getId() + \" обновлен в локальной БД на \" + newLikeState);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Отправляет запрос на сервер для изменения статуса \"лайк\"\r\n     */\r\n    private void sendLikeRequest(String userId, int recipeId, boolean isLiked) {\r\n        try {\r\n            JSONObject jsonObject = new JSONObject();\r\n            jsonObject.put(\"recipeId\", recipeId);\r\n            jsonObject.put(\"userId\", userId);\r\n            \r\n            String jsonBody = jsonObject.toString();\r\n            Log.d(TAG, \"Отправка запроса лайка: \" + jsonBody);\r\n            \r\n            RequestBody body = RequestBody.create(jsonBody, JSON);\r\n            \r\n            Request request = new Request.Builder()\r\n                    .url(com.example.cooking.config.ServerConfig.getFullUrl(\"/like\"))\r\n                    .post(body)\r\n                    .build();\r\n            \r\n            client.newCall(request).enqueue(new Callback() {\r\n                @Override\r\n                public void onFailure(@NonNull Call call, @NonNull IOException e) {\r\n                    Log.e(TAG, \"Ошибка сети при изменении лайка\", e);\r\n                    errorMessage.postValue(\"Ошибка сети: \" + e.getMessage());\r\n                }\r\n                \r\n                @Override\r\n                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\r\n                    if (response.isSuccessful()) {\r\n                        Log.d(TAG, \"Успешный ответ от сервера на изменение лайка\");\r\n                    } else {\r\n                        Log.e(TAG, \"Ошибка сервера при изменении лайка: \" + response.code() + \" \" + response.message());\r\n                        String responseBody = response.body() != null ? response.body().string() : \"No body\";\r\n                        Log.e(TAG, \"Тело ответа: \" + responseBody);\r\n                        errorMessage.postValue(\"Ошибка сервера: \" + response.code());\r\n                    }\r\n                    if (response.body() != null) {\r\n                        response.body().close();\r\n                    }\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            Log.e(TAG, \"Ошибка при создании запроса на изменение лайка\", e);\r\n            errorMessage.postValue(\"Ошибка приложения: \" + e.getMessage());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Выполняет удаление рецепта\r\n     * @param recipeId ID удаляемого рецепта\r\n     */\r\n    public void deleteRecipe(int recipeId) {\r\n        Recipe currentRecipe = recipe.getValue();\r\n        if (currentRecipe == null || currentRecipe.getId() != recipeId) {\r\n            Log.e(TAG, \"Невозможно удалить: текущий рецепт не совпадает с ID \" + recipeId);\r\n            errorMessage.postValue(\"Ошибка удаления: Несоответствие данных.\");\r\n            return;\r\n        }\r\n        \r\n        String currentUserId = preferences.getString(\"userId\", \"0\");\r\n        int permission = preferences.getInt(\"permission\", 1);\r\n        \r\n        boolean canDelete = (currentRecipe.getUserId() != null && currentRecipe.getUserId().equals(currentUserId)) || permission == 2;\r\n        if (!canDelete) {\r\n            errorMessage.postValue(\"У вас нет прав на удаление этого рецепта.\");\r\n            return;\r\n        }\r\n        \r\n        isDeleting.postValue(true);\r\n        \r\n        recipeDeleter.deleteRecipe(recipeId, currentUserId, permission,\r\n                new RecipeDeleter.DeleteRecipeCallback() {\r\n            @Override\r\n            public void onDeleteSuccess() {\r\n                Log.d(TAG, \"Рецепт с ID \" + recipeId + \" успешно удален.\");\r\n                recipe.postValue(null);\r\n                isDeleting.postValue(false);\r\n                deleteSuccess.postValue(true);\r\n                // Удаляем рецепт из локальной базы данных\r\n                localRepository.deleteRecipe(recipeId);\r\n            }\r\n            @Override\r\n            public void onDeleteFailure(String error) {\r\n                Log.e(TAG, \"Ошибка удаления рецепта ID \" + recipeId + \": \" + error);\r\n                errorMessage.postValue(\"Ошибка удаления: \" + error);\r\n                isDeleting.postValue(false);\r\n                deleteSuccess.postValue(false);\r\n            }\r\n        });\r\n    }\r\n    \r\n    @Override\r\n    protected void onCleared() {\r\n        super.onCleared();\r\n        executor.shutdown();\r\n    }\r\n\r\n    /**\r\n     * Выполняет задачу в фоновом потоке, если ViewModel активна.\r\n     */\r\n    private void executeIfActive(Runnable task) {\r\n        if (!executor.isShutdown()) {\r\n            executor.execute(task);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java b/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java
--- a/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java	(revision 69746fb2ac173c67d4965a5029136575c3dcd70b)
+++ b/app/src/main/java/com/example/cooking/ui/viewmodels/RecipeDetailViewModel.java	(date 1745090676851)
@@ -77,7 +77,6 @@
         executeIfActive(() -> {
             // Загружаем весь список из кэша
             RecipeRepository.Result<List<Recipe>> cachedResult = recipeRepository.loadFromCache();
-            
             if (cachedResult.isSuccess()) {
                 List<Recipe> cachedRecipes = ((RecipeRepository.Result.Success<List<Recipe>>) cachedResult).getData();
                 Recipe foundRecipe = null;
@@ -88,21 +87,52 @@
                         break;
                     }
                 }
-                
                 if (foundRecipe != null) {
                     recipe.postValue(foundRecipe);
                     isLiked.postValue(foundRecipe.isLiked()); // Устанавливаем статус лайка
                     checkEditPermission(foundRecipe.getUserId()); // Проверяем права
                     Log.d(TAG, "Рецепт ID " + recipeId + " найден в кэше: " + foundRecipe.getTitle());
                 } else {
-                    errorMessage.postValue("Рецепт с ID " + recipeId + " не найден в кэше.");
-                    Log.e(TAG, "Рецепт с ID " + recipeId + " не найден в загруженном кэше.");
+                    // Если рецепт не найден в кэше, пробуем загрузить с сервера
+                    fetchRecipeFromServer(recipeId);
                 }
             } else {
                 // Ошибка загрузки из кэша
                 String error = ((RecipeRepository.Result.Error<List<Recipe>>) cachedResult).getErrorMessage();
-                errorMessage.postValue("Ошибка загрузки из кэша: " + error);
                 Log.e(TAG, "Ошибка загрузки рецептов из кэша: " + error);
+                // Пробуем загрузить с сервера, если кэш пуст
+                fetchRecipeFromServer(recipeId);
+            }
+        });
+    }
+
+    private void fetchRecipeFromServer(int recipeId) {
+        // Показываем индикатор загрузки, если есть
+        // Можно добавить LiveData для прогресса
+        recipeRepository.getRecipes(new RecipeRepository.RecipesCallback() {
+            @Override
+            public void onRecipesLoaded(List<Recipe> recipes) {
+                Recipe foundRecipe = null;
+                for (Recipe r : recipes) {
+                    if (r.getId() == recipeId) {
+                        foundRecipe = r;
+                        break;
+                    }
+                }
+                if (foundRecipe != null) {
+                    recipe.postValue(foundRecipe);
+                    isLiked.postValue(foundRecipe.isLiked());
+                    checkEditPermission(foundRecipe.getUserId());
+                    Log.d(TAG, "Рецепт ID " + recipeId + " найден после загрузки с сервера: " + foundRecipe.getTitle());
+                } else {
+                    errorMessage.postValue("Рецепт с ID " + recipeId + " не найден на сервере.");
+                    Log.e(TAG, "Рецепт с ID " + recipeId + " не найден на сервере.");
+                }
+            }
+            @Override
+            public void onDataNotAvailable(String error) {
+                errorMessage.postValue("Ошибка загрузки рецепта: " + error + "\nПроверьте подключение к интернету и попробуйте обновить страницу.");
+                Log.e(TAG, "Ошибка загрузки рецепта с сервера: " + error);
             }
         });
     }
